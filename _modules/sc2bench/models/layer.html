

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sc2bench.models.layer &mdash; SC2 Benchmark v0.1.1-dev documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=e3745e35"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            SC2 Benchmark
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">üìö Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../package.html">sc2bench API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">üßëüèª‚Äçüíª Research</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../projects.html">Projects</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SC2 Benchmark</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sc2bench.models.layer</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sc2bench.models.layer</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">compressai.entropy_models</span><span class="w"> </span><span class="kn">import</span> <span class="n">GaussianConditional</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">compressai.layers</span><span class="w"> </span><span class="kn">import</span> <span class="n">GDN1</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">compressai.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">CompressionModel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">compressai.models.google</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_scale_table</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">compressai.models.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">update_registered_buffers</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch</span><span class="w"> </span><span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torchdistill.common.constant</span><span class="w"> </span><span class="kn">import</span> <span class="n">def_logger</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">def_logger</span><span class="o">.</span><span class="n">getChild</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">LAYER_CLASS_DICT</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">LAYER_FUNC_DICT</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>


<div class="viewcode-block" id="register_layer_class">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.register_layer_class">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">register_layer_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Registers a layer class.</span>

<span class="sd">    :param cls: layer class to be registered</span>
<span class="sd">    :type cls: class</span>
<span class="sd">    :return: registered layer class</span>
<span class="sd">    :rtype: class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LAYER_CLASS_DICT</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>
    <span class="k">return</span> <span class="bp">cls</span></div>



<div class="viewcode-block" id="register_layer_func">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.register_layer_func">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">register_layer_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Registers a function to build a layer module.</span>

<span class="sd">    :param func: function to build a layer module</span>
<span class="sd">    :type func: typing.Callable</span>
<span class="sd">    :return: registered function</span>
<span class="sd">    :rtype: typing.Callable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LAYER_FUNC_DICT</span><span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">func</span></div>



<div class="viewcode-block" id="SimpleBottleneck">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.SimpleBottleneck">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SimpleBottleneck</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple neural encoder-decoder that treats encoder&#39;s output as bottleneck.</span>

<span class="sd">    The forward path is encoder -&gt; compressor (if provided) -&gt; decompressor (if provided) -&gt; decoder.</span>

<span class="sd">    :param encoder: encoder</span>
<span class="sd">    :type encoder: nn.Module</span>
<span class="sd">    :param decoder: decoder</span>
<span class="sd">    :type decoder: nn.Module</span>
<span class="sd">    :param encoder: module to compress the encoded data</span>
<span class="sd">    :type encoder: nn.Module or None</span>
<span class="sd">    :param decoder: module to decompresse the compressed data</span>
<span class="sd">    :type decoder: nn.Module or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoder</span><span class="p">,</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">compressor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decompressor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">encoder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span> <span class="o">=</span> <span class="n">decoder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compressor</span> <span class="o">=</span> <span class="n">compressor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decompressor</span> <span class="o">=</span> <span class="n">decompressor</span>

<div class="viewcode-block" id="SimpleBottleneck.encode">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.SimpleBottleneck.encode">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encode the input data.</span>

<span class="sd">        :param x: input batch</span>
<span class="sd">        :type x: torch.Tensor</span>
<span class="sd">        :return: dict of encoded (and compressed if `compressor` is provided)</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressor</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">z</span><span class="p">}</span></div>


<div class="viewcode-block" id="SimpleBottleneck.decode">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.SimpleBottleneck.decode">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decode the encoded data.</span>

<span class="sd">        :param z: encoded data</span>
<span class="sd">        :type z: torch.Tensor</span>
<span class="sd">        :return: decoded data</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompressor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompressor</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">(</span><span class="n">z</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
            <span class="n">encoded_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">decoded_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="o">**</span><span class="n">encoded_obj</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">decoded_obj</span>

        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

<div class="viewcode-block" id="SimpleBottleneck.update">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.SimpleBottleneck.update">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shows a message that this module has no updatable parameters for entropy coding.</span>

<span class="sd">        Dummy function to be compatible with other layers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;This module has no updatable parameters for entropy coding&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="larger_resnet_bottleneck">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.larger_resnet_bottleneck">[docs]</a>
<span class="nd">@register_layer_func</span>
<span class="k">def</span><span class="w"> </span><span class="nf">larger_resnet_bottleneck</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">bottleneck_idx</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                             <span class="n">compressor_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decompressor_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a bottleneck layer ResNet-based encoder and decoder (24 layers in total).</span>

<span class="sd">    Compatible with ResNet-50, -101, and -152.</span>

<span class="sd">    Yoshitomo Matsubara, Davide Callegaro, Sabur Baidya, Marco Levorato, Sameer Singh: `&quot;Head Network Distillation: Splitting Distilled Deep Neural Networks for Resource-constrained Edge Computing Systems&quot; &lt;https://ieeexplore.ieee.org/document/9265295&gt;`_ @ IEEE Access (2020)</span>

<span class="sd">    :param bottleneck_channel: number of channels for the bottleneck point</span>
<span class="sd">    :type bottleneck_idx: int</span>
<span class="sd">    :param bottleneck_idx: number of the first layers to be used as an encoder (the remaining layers are for decoder)</span>
<span class="sd">    :type bottleneck_idx: int</span>
<span class="sd">    :param compressor_transform: compressor transform</span>
<span class="sd">    :type compressor_transform: nn.Module or None</span>
<span class="sd">    :param decompressor_transform: decompressor transform</span>
<span class="sd">    :type decompressor_transform: nn.Module or None</span>
<span class="sd">    :return: bottleneck layer consisting of encoder and decoder</span>
<span class="sd">    :rtype: SimpleBottleneck</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">modules</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">bottleneck_channel</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">512</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">512</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">512</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">AvgPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">encoder</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">[:</span><span class="n">bottleneck_idx</span><span class="p">])</span>
    <span class="n">decoder</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">[</span><span class="n">bottleneck_idx</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">SimpleBottleneck</span><span class="p">(</span><span class="n">encoder</span><span class="p">,</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">compressor_transform</span><span class="p">,</span> <span class="n">decompressor_transform</span><span class="p">)</span></div>



<div class="viewcode-block" id="larger_densenet_bottleneck">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.larger_densenet_bottleneck">[docs]</a>
<span class="nd">@register_layer_func</span>
<span class="k">def</span><span class="w"> </span><span class="nf">larger_densenet_bottleneck</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">bottleneck_idx</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                               <span class="n">compressor_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decompressor_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a bottleneck layer DenseNet-based encoder and decoder (23 layers in total).</span>

<span class="sd">    Compatible with DenseNet-169 and -201.</span>

<span class="sd">    Yoshitomo Matsubara, Davide Callegaro, Sabur Baidya, Marco Levorato, Sameer Singh: `&quot;Head Network Distillation: Splitting Distilled Deep Neural Networks for Resource-constrained Edge Computing Systems&quot; &lt;https://ieeexplore.ieee.org/document/9265295&gt;`_ @ IEEE Access (2020)</span>

<span class="sd">    :param bottleneck_channel: number of channels for the bottleneck point</span>
<span class="sd">    :type bottleneck_idx: int</span>
<span class="sd">    :param bottleneck_idx: number of the first layers to be used as an encoder (the remaining layers are for decoder)</span>
<span class="sd">    :type bottleneck_idx: int</span>
<span class="sd">    :param compressor_transform: compressor transform</span>
<span class="sd">    :type compressor_transform: nn.Module or None</span>
<span class="sd">    :param decompressor_transform: decompressor transform</span>
<span class="sd">    :type decompressor_transform: nn.Module or None</span>
<span class="sd">    :return: bottleneck layer consisting of encoder and decoder</span>
<span class="sd">    :rtype: SimpleBottleneck</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">modules</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">bottleneck_channel</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">512</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">512</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">AvgPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">encoder</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">[:</span><span class="n">bottleneck_idx</span><span class="p">])</span>
    <span class="n">decoder</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">[</span><span class="n">bottleneck_idx</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">SimpleBottleneck</span><span class="p">(</span><span class="n">encoder</span><span class="p">,</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">compressor_transform</span><span class="p">,</span> <span class="n">decompressor_transform</span><span class="p">)</span></div>



<div class="viewcode-block" id="inception_v3_bottleneck">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.inception_v3_bottleneck">[docs]</a>
<span class="nd">@register_layer_func</span>
<span class="k">def</span><span class="w"> </span><span class="nf">inception_v3_bottleneck</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">bottleneck_idx</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                            <span class="n">compressor_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decompressor_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a bottleneck layer InceptionV3-based encoder and decoder (17 layers in total).</span>

<span class="sd">    Yoshitomo Matsubara, Davide Callegaro, Sabur Baidya, Marco Levorato, Sameer Singh: `&quot;Head Network Distillation: Splitting Distilled Deep Neural Networks for Resource-constrained Edge Computing Systems&quot; &lt;https://ieeexplore.ieee.org/document/9265295&gt;`_ @ IEEE Access (2020)</span>

<span class="sd">    :param bottleneck_channel: number of channels for the bottleneck point</span>
<span class="sd">    :type bottleneck_idx: int</span>
<span class="sd">    :param bottleneck_idx: number of the first layers to be used as an encoder (the remaining layers are for decoder)</span>
<span class="sd">    :type bottleneck_idx: int</span>
<span class="sd">    :param compressor_transform: compressor transform</span>
<span class="sd">    :type compressor_transform: nn.Module or None</span>
<span class="sd">    :param decompressor_transform: decompressor transform</span>
<span class="sd">    :type decompressor_transform: nn.Module or None</span>
<span class="sd">    :return: bottleneck layer consisting of encoder and decoder</span>
<span class="sd">    :rtype: SimpleBottleneck</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">modules</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">bottleneck_channel</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">192</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">AvgPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">encoder</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">[:</span><span class="n">bottleneck_idx</span><span class="p">])</span>
    <span class="n">decoder</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">[</span><span class="n">bottleneck_idx</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">SimpleBottleneck</span><span class="p">(</span><span class="n">encoder</span><span class="p">,</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">compressor_transform</span><span class="p">,</span> <span class="n">decompressor_transform</span><span class="p">)</span></div>



<div class="viewcode-block" id="smaller_resnet_layer1_bottleneck">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.smaller_resnet_layer1_bottleneck">[docs]</a>
<span class="nd">@register_layer_func</span>
<span class="k">def</span><span class="w"> </span><span class="nf">smaller_resnet_layer1_bottleneck</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">bottleneck_idx</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                                     <span class="n">compressor_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decompressor_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a bottleneck layer ResNet-based encoder and decoder (20 layers in total).</span>

<span class="sd">    Compatible with the first layers of ResNet-18 and -34 until layer1.</span>

<span class="sd">    Yoshitomo Matsubara, Marco Levorato: `&quot;Neural Compression and Filtering for Edge-assisted Real-time Object Detection in Challenged Networks&quot; &lt;https://arxiv.org/abs/2007.15818&gt;`_ @ ICPR 2020 (2021)</span>

<span class="sd">    :param bottleneck_channel: number of channels for the bottleneck point</span>
<span class="sd">    :type bottleneck_idx: int</span>
<span class="sd">    :param bottleneck_idx: number of the first layers to be used as an encoder (the remaining layers are for decoder)</span>
<span class="sd">    :type bottleneck_idx: int</span>
<span class="sd">    :param compressor_transform: compressor transform</span>
<span class="sd">    :type compressor_transform: nn.Module or None</span>
<span class="sd">    :param decompressor_transform: decompressor transform</span>
<span class="sd">    :type decompressor_transform: nn.Module or None</span>
<span class="sd">    :return: bottleneck layer consisting of encoder and decoder</span>
<span class="sd">    :rtype: SimpleBottleneck</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">modules</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">bottleneck_channel</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">encoder</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">[:</span><span class="n">bottleneck_idx</span><span class="p">])</span>
    <span class="n">decoder</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">[</span><span class="n">bottleneck_idx</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">SimpleBottleneck</span><span class="p">(</span><span class="n">encoder</span><span class="p">,</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">compressor_transform</span><span class="p">,</span> <span class="n">decompressor_transform</span><span class="p">)</span></div>



<div class="viewcode-block" id="larger_resnet_layer1_bottleneck">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.larger_resnet_layer1_bottleneck">[docs]</a>
<span class="nd">@register_layer_func</span>
<span class="k">def</span><span class="w"> </span><span class="nf">larger_resnet_layer1_bottleneck</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">bottleneck_idx</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                                    <span class="n">compressor_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decompressor_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a bottleneck layer ResNet-based encoder and decoder (20 layers in total).</span>

<span class="sd">    Compatible with the first layers of ResNet-50, -101, and -152 until layer1.</span>

<span class="sd">    Yoshitomo Matsubara, Marco Levorato: `&quot;Neural Compression and Filtering for Edge-assisted Real-time Object Detection in Challenged Networks&quot; &lt;https://arxiv.org/abs/2007.15818&gt;`_ @ ICPR 2020 (2021)</span>

<span class="sd">    :param bottleneck_channel: number of channels for the bottleneck point</span>
<span class="sd">    :type bottleneck_idx: int</span>
<span class="sd">    :param bottleneck_idx: number of the first layers to be used as an encoder (the remaining layers are for decoder)</span>
<span class="sd">    :type bottleneck_idx: int</span>
<span class="sd">    :param compressor_transform: compressor transform</span>
<span class="sd">    :type compressor_transform: nn.Module or None</span>
<span class="sd">    :param decompressor_transform: decompressor transform</span>
<span class="sd">    :type decompressor_transform: nn.Module or None</span>
<span class="sd">    :return: bottleneck layer consisting of encoder and decoder</span>
<span class="sd">    :rtype: SimpleBottleneck</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">modules</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">bottleneck_channel</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">bottleneck_channel</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">encoder</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">[:</span><span class="n">bottleneck_idx</span><span class="p">])</span>
    <span class="n">decoder</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">[</span><span class="n">bottleneck_idx</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">SimpleBottleneck</span><span class="p">(</span><span class="n">encoder</span><span class="p">,</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">compressor_transform</span><span class="p">,</span> <span class="n">decompressor_transform</span><span class="p">)</span></div>



<div class="viewcode-block" id="EntropyBottleneckLayer">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.EntropyBottleneckLayer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EntropyBottleneckLayer</span><span class="p">(</span><span class="n">CompressionModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An entropy bottleneck layer as a simple `CompressionModel` in `compressai`.</span>

<span class="sd">    Johannes Ball√©, David Minnen, Saurabh Singh, Sung Jin Hwang, Nick Johnston: `&quot;Variational Image Compression with a Scale Hyperprior&quot; &lt;https://openreview.net/forum?id=rkcQFMZRb&gt;`_ @ ICLR 2018 (2018)</span>

<span class="sd">    :param kwargs: kwargs for `CompressionModel` in `compressai`</span>
<span class="sd">    :type kwargs: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updated</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="EntropyBottleneckLayer.compress">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.EntropyBottleneckLayer.compress">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compresses input data.</span>

<span class="sd">        :param x: input data</span>
<span class="sd">        :type x: torch.Tensor</span>
<span class="sd">        :return: entropy-coded compressed data (&#39;strings&#39; as key) and shape of the input data (&#39;shape&#39; as key)</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">strings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;strings&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">strings</span><span class="p">],</span> <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]}</span></div>


<div class="viewcode-block" id="EntropyBottleneckLayer.decompress">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.EntropyBottleneckLayer.decompress">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">decompress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strings</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dempresses compressed data.</span>

<span class="sd">        :param strings: entropy-coded compressed data</span>
<span class="sd">        :type strings: list[str]</span>
<span class="sd">        :param shape: shape of the input data</span>
<span class="sd">        :type shape: list[int]</span>
<span class="sd">        :return: decompressed data</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="EntropyBottleneckLayer.update">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.EntropyBottleneckLayer.update">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates compression-specific parameters like `CompressAI models do &lt;https://interdigitalinc.github.io/CompressAI/models.html#compressai.models.CompressionModel.update&gt;`_.</span>

<span class="sd">        :param force: if True, overwrites previous values</span>
<span class="sd">        :type force: bool</span>
<span class="sd">        :return: True if one of the EntropyBottlenecks was updated</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updated</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="BaseBottleneck">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.BaseBottleneck">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseBottleneck</span><span class="p">(</span><span class="n">CompressionModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract class for entropy bottleneck-based layer.</span>

<span class="sd">    :param entropy_bottleneck_channels: number of entropy bottleneck channels</span>
<span class="sd">    :type entropy_bottleneck_channels: int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entropy_bottleneck_channels</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">entropy_bottleneck_channels</span><span class="o">=</span><span class="n">entropy_bottleneck_channels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updated</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="BaseBottleneck.encode">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.BaseBottleneck.encode">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encodes data.</span>

<span class="sd">        This should be overridden by all subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="BaseBottleneck.decode">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.BaseBottleneck.decode">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decodes encoded data.</span>

<span class="sd">        This should be overridden by all subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<div class="viewcode-block" id="BaseBottleneck.update">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.BaseBottleneck.update">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates compression-specific parameters like `CompressAI models do &lt;https://interdigitalinc.github.io/CompressAI/models.html#compressai.models.CompressionModel.update&gt;`_.</span>

<span class="sd">        :param force: if True, overwrites previous values</span>
<span class="sd">        :type force: bool</span>
<span class="sd">        :return: True if one of the EntropyBottlenecks was updated</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updated</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="FPBasedResNetBottleneck">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.FPBasedResNetBottleneck">[docs]</a>
<span class="nd">@register_layer_class</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FPBasedResNetBottleneck</span><span class="p">(</span><span class="n">BaseBottleneck</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factorized Prior(FP)-based encoder-decoder designed to create bottleneck for ResNet and variants.</span>

<span class="sd">    - Johannes Ball√©, David Minnen, Saurabh Singh, Sung Jin Hwang, Nick Johnston: `&quot;Variational Image Compression with a Scale Hyperprior&quot; &lt;https://openreview.net/forum?id=rkcQFMZRb&gt;`_ @ ICLR 2018 (2018)</span>
<span class="sd">    - Yoshitomo Matsubara, Ruihan Yang, Marco Levorato, Stephan Mandt: `&quot;Supervised Compression for Resource-Constrained Edge Computing Systems&quot; &lt;https://openaccess.thecvf.com/content/WACV2022/html/Matsubara_Supervised_Compression_for_Resource-Constrained_Edge_Computing_Systems_WACV_2022_paper.html&gt;`_ @ WACV 2022 (2022)</span>
<span class="sd">    - Yoshitomo Matsubara, Ruihan Yang, Marco Levorato, Stephan Mandt: `&quot;SC2 Benchmark: Supervised Compression for Split Computing&quot; &lt;https://openreview.net/forum?id=p28wv4G65d&gt;`_ @ TMLR (2023)</span>

<span class="sd">    :param num_input_channels: number of input channels</span>
<span class="sd">    :type num_input_channels: int</span>
<span class="sd">    :param num_bottleneck_channels: number of bottleneck channels</span>
<span class="sd">    :type num_bottleneck_channels: int</span>
<span class="sd">    :param num_target_channels: number of output channels for decoder&#39;s output</span>
<span class="sd">    :type num_target_channels: int</span>
<span class="sd">    :param encoder_channel_sizes: list of 4 numbers of channels for encoder</span>
<span class="sd">    :type encoder_channel_sizes: list[int] or None</span>
<span class="sd">    :param decoder_channel_sizes: list of 4 numbers of channels for decoder</span>
<span class="sd">    :type decoder_channel_sizes: list[int] or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_input_channels</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_bottleneck_channels</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">num_target_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span>
                 <span class="n">encoder_channel_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decoder_channel_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">encoder_channel_sizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">encoder_channel_sizes</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">num_input_channels</span><span class="p">,</span> <span class="n">num_bottleneck_channels</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">num_bottleneck_channels</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_bottleneck_channels</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">decoder_channel_sizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">decoder_channel_sizes</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">encoder_channel_sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_target_channels</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_target_channels</span><span class="p">,</span> <span class="n">num_target_channels</span><span class="p">]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">entropy_bottleneck_channels</span><span class="o">=</span><span class="n">num_bottleneck_channels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">encoder_channel_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">encoder_channel_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                      <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">GDN1</span><span class="p">(</span><span class="n">encoder_channel_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">encoder_channel_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">encoder_channel_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                      <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">GDN1</span><span class="p">(</span><span class="n">encoder_channel_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">encoder_channel_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">encoder_channel_sizes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                      <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">decoder_channel_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">decoder_channel_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                      <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">GDN1</span><span class="p">(</span><span class="n">decoder_channel_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">decoder_channel_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">decoder_channel_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                      <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">GDN1</span><span class="p">(</span><span class="n">decoder_channel_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">decoder_channel_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">decoder_channel_sizes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                      <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="FPBasedResNetBottleneck.encode">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.FPBasedResNetBottleneck.encode">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encodes input data.</span>

<span class="sd">        :param x: input data</span>
<span class="sd">        :type x: torch.Tensor</span>
<span class="sd">        :return: entropy-coded compressed data (&#39;strings&#39; as key) and shape of the input data (&#39;shape&#39; as key)</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">latent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">latent_strings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">latent</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;strings&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">latent_strings</span><span class="p">],</span> <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">latent</span><span class="o">.</span><span class="n">size</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]}</span></div>


<div class="viewcode-block" id="FPBasedResNetBottleneck.decode">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.FPBasedResNetBottleneck.decode">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strings</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decodes encoded data.</span>

<span class="sd">        :param strings: entropy-coded compressed data</span>
<span class="sd">        :type strings: list[str]</span>
<span class="sd">        :param shape: shape of the input data</span>
<span class="sd">        :type shape: list[int]</span>
<span class="sd">        :return: decompressed data</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">latent_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">(</span><span class="n">latent_hat</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_means</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">medians</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">_get_medians</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="n">spatial_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">())</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="n">medians</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">_extend_ndims</span><span class="p">(</span><span class="n">medians</span><span class="p">,</span> <span class="n">spatial_dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">medians</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">spatial_dims</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_forward2train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">encoded_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y_hat</span><span class="p">,</span> <span class="n">y_likelihoods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="p">(</span><span class="n">encoded_obj</span><span class="p">)</span>
        <span class="n">decoded_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">(</span><span class="n">y_hat</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">decoded_obj</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># if fine-tune or evaluate after &quot;update&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">updated</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
                <span class="n">encoded_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">decoded_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="o">**</span><span class="n">encoded_obj</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">decoded_obj</span>

            <span class="n">encoded_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">decoder_input</span> <span class="o">=</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">dequantize</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">encoded_output</span><span class="p">,</span> <span class="s1">&#39;dequantize&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_means</span><span class="p">(</span><span class="n">encoded_output</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="n">decoder_input</span> <span class="o">=</span> <span class="n">decoder_input</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">(</span><span class="n">decoder_input</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_forward2train</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>



<div class="viewcode-block" id="SHPBasedResNetBottleneck">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.SHPBasedResNetBottleneck">[docs]</a>
<span class="nd">@register_layer_class</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SHPBasedResNetBottleneck</span><span class="p">(</span><span class="n">BaseBottleneck</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scale Hyperprior(SHP)-based bottleneck for ResNet and variants.</span>

<span class="sd">    - Johannes Ball√©, David Minnen, Saurabh Singh, Sung Jin Hwang, Nick Johnston: `&quot;Variational Image Compression with a Scale Hyperprior&quot; &lt;https://openreview.net/forum?id=rkcQFMZRb&gt;`_ @ ICLR 2018 (2018)</span>
<span class="sd">    - Yoshitomo Matsubara, Ruihan Yang, Marco Levorato, Stephan Mandt: `&quot;SC2 Benchmark: Supervised Compression for Split Computing&quot; &lt;https://openreview.net/forum?id=p28wv4G65d&gt;`_ @ TMLR (2023)</span>

<span class="sd">    :param num_input_channels: number of input channels</span>
<span class="sd">    :type num_input_channels: int</span>
<span class="sd">    :param num_latent_channels: number of latent channels</span>
<span class="sd">    :type num_latent_channels: int</span>
<span class="sd">    :param num_bottleneck_channels: number of bottleneck channels</span>
<span class="sd">    :type num_bottleneck_channels: int</span>
<span class="sd">    :param num_target_channels: number of output channels for decoder&#39;s output</span>
<span class="sd">    :type num_target_channels: int</span>
<span class="sd">    :param h_a: parametric transform :math:`h_a`</span>
<span class="sd">    :type h_a: nn.Module or None</span>
<span class="sd">    :param h_s: parametric transform :math:`h_s`</span>
<span class="sd">    :type h_s: nn.Module or None</span>
<span class="sd">    :param g_a_channel_sizes: list of 4 numbers of channels for parametric transform :math:`g_a`</span>
<span class="sd">    :type g_a_channel_sizes: list[int] or None</span>
<span class="sd">    :param g_s_channel_sizes: list of 4 numbers of channels for parametric transform :math:`g_s`</span>
<span class="sd">    :type g_s_channel_sizes: list[int] or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_input_channels</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_latent_channels</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
                 <span class="n">num_bottleneck_channels</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">num_target_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">h_a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">h_s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">g_a_channel_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">g_s_channel_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">g_a_channel_sizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g_a_channel_sizes</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">num_input_channels</span><span class="p">,</span> <span class="n">num_bottleneck_channels</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">num_bottleneck_channels</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_bottleneck_channels</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_bottleneck_channels</span> <span class="o">=</span> <span class="n">g_a_channel_sizes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">g_s_channel_sizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g_s_channel_sizes</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">g_a_channel_sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_target_channels</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_target_channels</span><span class="p">,</span> <span class="n">num_target_channels</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">entropy_bottleneck_channels</span><span class="o">=</span><span class="n">num_latent_channels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g_a</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">g_a_channel_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">g_a_channel_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                      <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">GDN1</span><span class="p">(</span><span class="n">g_a_channel_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">g_a_channel_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">g_a_channel_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                      <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">GDN1</span><span class="p">(</span><span class="n">g_a_channel_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">g_a_channel_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">g_a_channel_sizes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                      <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">g_s</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">g_s_channel_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">g_s_channel_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">GDN1</span><span class="p">(</span><span class="n">g_s_channel_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">g_s_channel_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">g_s_channel_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">GDN1</span><span class="p">(</span><span class="n">g_s_channel_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">g_s_channel_sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">g_s_channel_sizes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">h_a</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">num_bottleneck_channels</span><span class="p">,</span> <span class="n">num_latent_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">num_latent_channels</span><span class="p">,</span> <span class="n">num_latent_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span> <span class="k">if</span> <span class="n">h_a</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">h_a</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">h_s</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">ConvTranspose2d</span><span class="p">(</span><span class="n">num_latent_channels</span><span class="p">,</span> <span class="n">num_latent_channels</span><span class="p">,</span>
                               <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">ConvTranspose2d</span><span class="p">(</span><span class="n">num_latent_channels</span><span class="p">,</span> <span class="n">num_latent_channels</span><span class="p">,</span>
                               <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">num_latent_channels</span><span class="p">,</span> <span class="n">num_bottleneck_channels</span><span class="p">,</span>
                      <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span> <span class="k">if</span> <span class="n">h_s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">h_s</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span> <span class="o">=</span> <span class="n">GaussianConditional</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_latent_channels</span> <span class="o">=</span> <span class="n">num_latent_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_bottleneck_channels</span> <span class="o">=</span> <span class="n">num_bottleneck_channels</span>

<div class="viewcode-block" id="SHPBasedResNetBottleneck.encode">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.SHPBasedResNetBottleneck.encode">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encodes input data.</span>

<span class="sd">        :param x: input data</span>
<span class="sd">        :type x: torch.Tensor</span>
<span class="sd">        :return: entropy-coded compressed data (&#39;strings&#39; as key) and shape of the input data (&#39;shape&#39; as key)</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_a</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="n">z_shape</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">size</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">z_strings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">z_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="n">z_strings</span><span class="p">,</span> <span class="n">z_shape</span><span class="p">)</span>
        <span class="n">scales_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_s</span><span class="p">(</span><span class="n">z_hat</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="o">.</span><span class="n">build_indexes</span><span class="p">(</span><span class="n">scales_hat</span><span class="p">)</span>
        <span class="n">y_strings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;strings&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">y_strings</span><span class="p">,</span> <span class="n">z_strings</span><span class="p">],</span> <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">z_shape</span><span class="p">}</span></div>


<div class="viewcode-block" id="SHPBasedResNetBottleneck.decode">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.SHPBasedResNetBottleneck.decode">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strings</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decodes encoded data.</span>

<span class="sd">        :param strings: entropy-coded compressed data</span>
<span class="sd">        :type strings: list[str]</span>
<span class="sd">        :param shape: shape of the input data</span>
<span class="sd">        :type shape: list[int]</span>
<span class="sd">        :return: decompressed data</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">z_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">)</span>
        <span class="n">scales_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_s</span><span class="p">(</span><span class="n">z_hat</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="o">.</span><span class="n">build_indexes</span><span class="p">(</span><span class="n">scales_hat</span><span class="p">)</span>
        <span class="n">y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">,</span> <span class="n">z_hat</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_s</span><span class="p">(</span><span class="n">y_hat</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_means</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">medians</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">_get_medians</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="n">spatial_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">())</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="n">medians</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">_extend_ndims</span><span class="p">(</span><span class="n">medians</span><span class="p">,</span> <span class="n">spatial_dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">medians</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">spatial_dims</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_forward2train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_a</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="n">z_hat</span><span class="p">,</span> <span class="n">z_likelihoods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">scales_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_s</span><span class="p">(</span><span class="n">z_hat</span><span class="p">)</span>
        <span class="n">y_hat</span><span class="p">,</span> <span class="n">y_likelihoods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">scales_hat</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_s</span><span class="p">(</span><span class="n">y_hat</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># if fine-tune or evaluate after &quot;update&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">updated</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
                <span class="n">encoded_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">decoded_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="o">**</span><span class="n">encoded_obj</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">decoded_obj</span>

            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="o">.</span><span class="n">dequantize</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;dequantize&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_means</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">y_hat</span> <span class="o">=</span> <span class="n">y_hat</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_s</span><span class="p">(</span><span class="n">y_hat</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_forward2train</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="SHPBasedResNetBottleneck.update">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.SHPBasedResNetBottleneck.update">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale_table</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scale_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_table</span> <span class="o">=</span> <span class="n">get_scale_table</span><span class="p">()</span>

        <span class="n">updated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="o">.</span><span class="n">update_scale_table</span><span class="p">(</span><span class="n">scale_table</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>
        <span class="n">updated</span> <span class="o">|=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updated</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">updated</span></div>


<div class="viewcode-block" id="SHPBasedResNetBottleneck.load_state_dict">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.SHPBasedResNetBottleneck.load_state_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_state_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates registered buffers and loads parameters.</span>

<span class="sd">        :param state_dict: dict containing parameters and persistent buffers</span>
<span class="sd">        :type state_dict: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">update_registered_buffers</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="p">,</span>
            <span class="s1">&#39;gaussian_conditional&#39;</span><span class="p">,</span>
            <span class="p">[</span><span class="s1">&#39;_quantized_cdf&#39;</span><span class="p">,</span> <span class="s1">&#39;_offset&#39;</span><span class="p">,</span> <span class="s1">&#39;_cdf_length&#39;</span><span class="p">,</span> <span class="s1">&#39;scale_table&#39;</span><span class="p">],</span>
            <span class="n">state_dict</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="MSHPBasedResNetBottleneck">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.MSHPBasedResNetBottleneck">[docs]</a>
<span class="nd">@register_layer_class</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MSHPBasedResNetBottleneck</span><span class="p">(</span><span class="n">SHPBasedResNetBottleneck</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mean-Scale Hyperprior(MSHP)-based bottleneck for ResNet and variants.</span>

<span class="sd">    - David Minnen, Johannes Ball√©, George Toderici: `&quot;Joint Autoregressive and Hierarchical Priors for Learned Image Compression&quot; &lt;https://proceedings.neurips.cc/paper/2018/hash/53edebc543333dfbf7c5933af792c9c4-Abstract.html&gt;`_ @ NeurIPS 2018 (2018)</span>
<span class="sd">    - Yoshitomo Matsubara, Ruihan Yang, Marco Levorato, Stephan Mandt: `&quot;SC2 Benchmark: Supervised Compression for Split Computing&quot; &lt;https://openreview.net/forum?id=p28wv4G65d&gt;`_ @ TMLR (2023)</span>

<span class="sd">    :param num_input_channels: number of input channels</span>
<span class="sd">    :type num_input_channels: int</span>
<span class="sd">    :param num_latent_channels: number of latent channels</span>
<span class="sd">    :type num_latent_channels: int</span>
<span class="sd">    :param num_bottleneck_channels: number of bottleneck channels</span>
<span class="sd">    :type num_bottleneck_channels: int</span>
<span class="sd">    :param num_target_channels: number of output channels for decoder&#39;s output</span>
<span class="sd">    :type num_target_channels: int</span>
<span class="sd">    :param g_a_channel_sizes: list of 4 numbers of channels for parametric transform :math:`g_a`</span>
<span class="sd">    :type g_a_channel_sizes: list[int] or None</span>
<span class="sd">    :param g_s_channel_sizes: list of 4 numbers of channels for parametric transform :math:`g_s`</span>
<span class="sd">    :type g_s_channel_sizes: list[int] or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_input_channels</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_latent_channels</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
                 <span class="n">num_bottleneck_channels</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">num_target_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span>
                 <span class="n">g_a_channel_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">g_s_channel_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">h_a</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">num_bottleneck_channels</span><span class="p">,</span> <span class="n">num_latent_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">num_latent_channels</span><span class="p">,</span> <span class="n">num_latent_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">h_s</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">ConvTranspose2d</span><span class="p">(</span><span class="n">num_latent_channels</span><span class="p">,</span> <span class="n">num_latent_channels</span><span class="p">,</span>
                               <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">ConvTranspose2d</span><span class="p">(</span><span class="n">num_latent_channels</span><span class="p">,</span> <span class="n">num_latent_channels</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                               <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">num_latent_channels</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_bottleneck_channels</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                      <span class="n">kernel_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_input_channels</span><span class="o">=</span><span class="n">num_input_channels</span><span class="p">,</span> <span class="n">num_latent_channels</span><span class="o">=</span><span class="n">num_latent_channels</span><span class="p">,</span>
                         <span class="n">num_bottleneck_channels</span><span class="o">=</span><span class="n">num_bottleneck_channels</span><span class="p">,</span> <span class="n">num_target_channels</span><span class="o">=</span><span class="n">num_target_channels</span><span class="p">,</span>
                         <span class="n">h_a</span><span class="o">=</span><span class="n">h_a</span><span class="p">,</span> <span class="n">h_s</span><span class="o">=</span><span class="n">h_s</span><span class="p">,</span> <span class="n">g_a_channel_sizes</span><span class="o">=</span><span class="n">g_a_channel_sizes</span><span class="p">,</span> <span class="n">g_s_channel_sizes</span><span class="o">=</span><span class="n">g_s_channel_sizes</span><span class="p">)</span>

<div class="viewcode-block" id="MSHPBasedResNetBottleneck.encode">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.MSHPBasedResNetBottleneck.encode">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_a</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">z_strings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">z_shape</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">size</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">z_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="n">z_strings</span><span class="p">,</span> <span class="n">z_shape</span><span class="p">)</span>
        <span class="n">gaussian_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_s</span><span class="p">(</span><span class="n">z_hat</span><span class="p">)</span>
        <span class="n">scales_hat</span><span class="p">,</span> <span class="n">means_hat</span> <span class="o">=</span> <span class="n">gaussian_params</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="o">.</span><span class="n">build_indexes</span><span class="p">(</span><span class="n">scales_hat</span><span class="p">)</span>
        <span class="n">y_strings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">means</span><span class="o">=</span><span class="n">means_hat</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;strings&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">y_strings</span><span class="p">,</span> <span class="n">z_strings</span><span class="p">],</span> <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">z_shape</span><span class="p">}</span></div>


<div class="viewcode-block" id="MSHPBasedResNetBottleneck.decode">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.MSHPBasedResNetBottleneck.decode">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strings</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">z_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">)</span>
        <span class="n">gaussian_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_s</span><span class="p">(</span><span class="n">z_hat</span><span class="p">)</span>
        <span class="n">scales_hat</span><span class="p">,</span> <span class="n">means_hat</span> <span class="o">=</span> <span class="n">gaussian_params</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="o">.</span><span class="n">build_indexes</span><span class="p">(</span><span class="n">scales_hat</span><span class="p">)</span>
        <span class="n">y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">,</span> <span class="n">means</span><span class="o">=</span><span class="n">means_hat</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_s</span><span class="p">(</span><span class="n">y_hat</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_forward2train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_a</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">z_hat</span><span class="p">,</span> <span class="n">z_likelihoods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">gaussian_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_s</span><span class="p">(</span><span class="n">z_hat</span><span class="p">)</span>
        <span class="n">scales_hat</span><span class="p">,</span> <span class="n">means_hat</span> <span class="o">=</span> <span class="n">gaussian_params</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y_hat</span><span class="p">,</span> <span class="n">y_likelihoods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">scales_hat</span><span class="p">,</span> <span class="n">means</span><span class="o">=</span><span class="n">means_hat</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_s</span><span class="p">(</span><span class="n">y_hat</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># if fine-tune or evaluate after &quot;update&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">updated</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
                <span class="n">encoded_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">decoded_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="o">**</span><span class="n">encoded_obj</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">decoded_obj</span>

            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_a</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">z_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">dequantize</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entropy_bottleneck</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="s1">&#39;dequantize&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_means</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">gaussian_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_s</span><span class="p">(</span><span class="n">z_hat</span><span class="p">)</span>
            <span class="n">scales_hat</span><span class="p">,</span> <span class="n">means_hat</span> <span class="o">=</span> <span class="n">gaussian_params</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="o">.</span><span class="n">dequantize</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_conditional</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;dequantize&#39;</span><span class="p">,</span> <span class="n">means_hat</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">y_hat</span> <span class="o">=</span> <span class="n">y_hat</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_s</span><span class="p">(</span><span class="n">y_hat</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_forward2train</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_layer">
<a class="viewcode-back" href="../../../subpkgs/models.html#sc2bench.models.layer.get_layer">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_layer</span><span class="p">(</span><span class="n">cls_or_func_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets a layer module.</span>

<span class="sd">    :param cls_or_func_name: layer class or function name</span>
<span class="sd">    :type cls_or_func_name: str</span>
<span class="sd">    :param kwargs: kwargs for the layer class or function to build a layer</span>
<span class="sd">    :type kwargs: dict</span>
<span class="sd">    :return: layer module</span>
<span class="sd">    :rtype: nn.Module or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cls_or_func_name</span> <span class="ow">in</span> <span class="n">LAYER_CLASS_DICT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">LAYER_CLASS_DICT</span><span class="p">[</span><span class="n">cls_or_func_name</span><span class="p">](</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cls_or_func_name</span> <span class="ow">in</span> <span class="n">LAYER_FUNC_DICT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">LAYER_FUNC_DICT</span><span class="p">[</span><span class="n">cls_or_func_name</span><span class="p">](</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Yoshitomo Matsubara.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-39T9X4DN85"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-39T9X4DN85', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>